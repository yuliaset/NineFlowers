<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Riichi Mahjong Demo ‚Äì Defesa & Autoplay</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        :root{--gap:.4rem;--radius:1rem;--shadow:0 4px 6px rgb(0 0 0 /.1);font-family:system-ui,sans-serif}
        body{margin:0;background:#f8f9fa;padding:1rem}
        #bgImage {
        position: fixed;
        bottom: 0;
        right: 0;
        z-index: 10000;       
        pointer-events: none; 
        }
        h1{text-align:center;margin:0 0 1rem}
        p.description{text-align:center;max-width:800px;margin:0 auto 1.5rem;color:#333;font-size:1rem;line-height:1.4}

        #table{display:grid;grid-template-rows:repeat(4,auto);gap:var(--gap);max-width:1200px;margin:0 auto}
        .player{background:#fff;border-radius:var(--radius);padding:.6rem 1rem;box-shadow:var(--shadow);transition:transform .2s}
        .winner{border:3px solid #16a34a;transform:scale(1.04)}
        .row{display:flex;flex-wrap:wrap;align-items:center;gap:.2rem}
        .meld{margin-left:.6rem;padding-left:.4rem;border-left:2px solid #e2e8f0}
        .discards{border-top:1px dashed #cbd5e1;padding-top:.25rem;margin-top:.25rem}
        .tile{font-family:"Noto Sans Symbols 2","Segoe UI Symbol","Apple Color Emoji",sans-serif;font-size:2rem;display:inline-block}
        .rot{transform:rotate(90deg)}
        .sm{font-size:1.6rem;opacity:.85}
        .riichi-tag{color:#dc2626;font-weight:700;margin-left:.4rem}
        .role{font-size:.75rem;padding:.1rem .4rem;border-radius:.4rem;background:#e2e8f0;margin-left:.4rem}
        .def{background:#c7d2fe}
        .off{background:#fee2e2}
        #controls{text-align:center;margin:1.5rem auto;display:flex;justify-content:center;gap:.8rem}
        button{border:0;border-radius:.5rem;box-shadow:var(--shadow);background:#4f46e5;color:#fff;padding:.5rem 1.6rem;font-size:1rem;cursor:pointer}
        button:disabled{background:#9ca3af;cursor:not-allowed}
        #log{display:none;max-width:1200px;margin:.5rem auto;height:22rem;background:#fff;border-radius:.6rem;box-shadow:var(--shadow);padding:.8rem 1rem;font:.9rem/1.3 monospace;white-space:pre-wrap;overflow-y:auto}
    </style>
</head>

<body>
    <img id="bgImage" src="background.png" alt="" />
    <h1>NineFlowers üÄê Mahjong Algor√≠tmico</h1>
    <p class="description">
        O algoritmo de descartes equilibra defensiva e ofensiva para manter o jogador em tenpai:
        <ul style="list-style:disc;margin:0.5rem 0 0 1.2rem;text-align:left;max-width:600px;margin-left:auto;margin-right:auto;">
            <li>Com Riichi ativo, jogadores defensivos priorizam genbutsu e suji para evitar perigos;</li>
            <li>Em m√£os ofensivas, simula cada descarte calculando o Shanten restante e o Ukeire potencial, escolhendo o que minimiza o Shanten e maximiza o Ukeire.</li>
        </ul>
    </p>
    <div id="table"></div>
    <div id="controls">
        <button id="next">Pr√≥ximo turno</button>
        <button id="auto">Autoplay ‚ñ∂</button>
        <button id="reset">Reset</button>
    </div>
    <pre id="log"></pre>

    <script>
        const U=["\u{1F007}","\u{1F008}","\u{1F009}","\u{1F00A}","\u{1F00B}","\u{1F00C}","\u{1F00D}","\u{1F00E}","\u{1F00F}","\u{1F019}","\u{1F01A}","\u{1F01B}","\u{1F01C}","\u{1F01D}","\u{1F01E}","\u{1F01F}","\u{1F020}","\u{1F021}","\u{1F010}","\u{1F011}","\u{1F012}","\u{1F013}","\u{1F014}","\u{1F015}","\u{1F016}","\u{1F017}","\u{1F018}","\u{1F000}","\u{1F001}","\u{1F002}","\u{1F003}","\u{1F006}","\u{1F005}","\u{1F004}"];
        const span=(t,{rot=false,sm=false}={})=>`<span class="tile${rot?" rot":""}${sm?" sm":""}">${U[t]}</span>`;
        const key=a=>a.join("");
        function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}}
        function isSuji(t){if(t>=27) return true; const r=t%9+1; return r===1||r===4||r===7;}

        let wall,wc,P,pos,turn,cur,MAX,riichiActive,safeTiles,autoTimer;

        function initGame(){
          wall=[...Array(4).keys()].flatMap(()=>Array.from({length:34},(_,i)=>i)); shuffle(wall);
          wc=Array(34).fill(4);
          P=[0,1,2,3].map(i=>new Player(i));
          pos=0;turn=0;cur=0;MAX=68;riichiActive=false;safeTiles=new Set();
          for(let d=0;d<13;d++)P.forEach(p=>p.add(draw())); P.forEach(p=>p.sort());
          logEl.textContent="Partida reiniciada (13 tiles).\n";
          render(); enableButtons(); autoBtn.textContent="Autoplay ‚ñ∂"; clearInterval(autoTimer); autoTimer=null;
        }

        const M1=new Map(),M2=new Map();
        function suitDFS(c){const k=key(c);if(M1.has(k))return M1.get(k);let best=[0,0];const up=(m,t)=>{if(m>best[0]||m===best[0]&&t>best[1])best=[m,t]};let i=c.findIndex(x=>x);if(i<0)return M1.set(k,best),best;
          if(c[i]>=3){c[i]-=3;const[r,s]=suitDFS(c);up(r+1,s);c[i]+=3}
          if(i<=6&&c[i]&&c[i+1]&&c[i+2]){c[i]--;c[i+1]--;c[i+2]--;const[r,s]=suitDFS(c);up(r+1,s);c[i]++;c[i+1]++;c[i+2]++;}
          if(c[i]>=2){c[i]-=2;const[r,s]=suitDFS(c);up(r,s+1);c[i]+=2}
          if(i<=7&&c[i]&&c[i+1]){c[i]--;c[i+1]--;const[r,s]=suitDFS(c);up(r,s+1);c[i]++;c[i+1]++;}
          if(i<=6&&c[i]&&c[i+2]){c[i]--;c[i+2]--;const[r,s]=suitDFS(c);up(r,s+1);c[i]++;c[i+2]++;}
          const sv=c[i];c[i]=0;const[r,s]=suitDFS(c);up(r,s);c[i]=sv;
          return M1.set(k,best),best;}
        function honorDFS(c){const k=key(c);if(M2.has(k))return M2.get(k);let best=[0,0];const up=(m,t)=>{if(m>best[0]||m===best[0]&&t>best[1])best=[m,t]};let i=c.findIndex(x=>x);if(i<0)return M2.set(k,best),best;
          if(c[i]>=3){c[i]-=3;const[r,s]=honorDFS(c);up(r+1,s);c[i]+=3}
          if(c[i]>=2){c[i]-=2;const[r,s]=honorDFS(c);up(r,s+1);c[i]+=2}
          c[i]--;const[r,s]=honorDFS(c);up(r,s);c[i]++;
          return M2.set(k,best),best;}
        function stdShanten(ct){const meldTa=C=>{let m=0,t=0;for(const b of[0,9,18]){const[r,s]=suitDFS(C.slice(b,b+9));m+=r;t+=s}const[r2,s2]=honorDFS(C.slice(27));return[m+r2,t+s2]};
          let min=8;for(let i=0;i<34;i++)if(ct[i]>=2){ct[i]-=2;const[m,t]=meldTa(ct);ct[i]+=2;min=Math.min(min,8-2*m-Math.min(t,4-m)-1);}const[m,t]=meldTa(ct);return Math.min(min,8-2*m-Math.min(t,4-m));}
        function ukeire(ct,sh){let u=0;for(let i=0;i<34;i++){if(!wc[i])continue;ct[i]++;if(stdShanten(ct)<sh)u+=wc[i];ct[i]--;}return u;}

        class Player{
          constructor(id){
            this.id=id;
            this.h=[];
            this.ct=Array(34).fill(0);
            this.melds=[];
            this.disc=[];
            this.win=false;
            this.riichi=false;
            this.lastDrawTile=null; 
            this.defensive=Math.random()<0.5;
          }
          add(t){this.h.push(t);this.ct[t]++;}
          rm(t){this.h.splice(this.h.indexOf(t),1);this.ct[t]--;}
          sort(){this.h.sort((a,b)=>a-b);}
          sh(){return stdShanten(this.ct);}
          role(){return this.defensive?"Defensivo":"Ofensivo";}

        }

        function step(){if(turn>=MAX||pos>=wall.length){finish();return;} const pl=P[cur]; const tile=draw(); pl.add(tile); pl.lastDrawTile=tile; log(`P${cur} compra ${span(tile)}\n`);

          if(!pl.riichi && pl.melds.length===0){
            const shNow = pl.sh();
            if(shNow===0){ 

              pl.ct[tile]--;                             
              const shAfter = pl.sh();
              pl.ct[tile]++;                             
              if(shAfter===0 && !(riichiActive && pl.defensive)){
                pl.riichi=true; riichiActive=true; log(`*** P${cur} declara RICHI! ***
        `);
              }
            }
          }
          if(!pl.riichi && pl.melds.length===0 && pl.sh()+1===0){
            if(!(riichiActive && pl.defensive)) { 
              pl.riichi=true; riichiActive=true; log(`*** P${cur} declara RICHI! ***\n`);
              console.log(pl.sh())
            }
          }
          if(pl.sh()<0){win(pl,"TSUMO",tile);return;}
          pl.sort(); const idx=chooseDiscard(pl); const disc=pl.h[idx]; pl.rm(disc); pl.disc.push(disc); if(pl.riichi) safeTiles.add(disc); log(`P${cur} descarta ${span(disc)}${pl.riichi?" (richi)":""}\n`);
          if(callWindow(disc,cur))return; if(ronCheck(disc,cur))return; render(); cur=(cur+1)%4; turn++; if(turn>=MAX||pos>=wall.length){log("\nSem vencedor.\n"); finish();}}

        function chooseDiscard(pl){ if(pl.riichi) return pl.h.indexOf(pl.lastDrawTile); const sh0=pl.sh();
          if(riichiActive){

            const g=pl.h.find(t=>safeTiles.has(t));
            if(g!==undefined){ if(pl.defensive) return pl.h.indexOf(g); else { pl.ct[g]--; const ns=pl.sh(); pl.ct[g]++; if(ns<=sh0) return pl.h.indexOf(g); } }

            if(pl.defensive){ const s=pl.h.find(t=>isSuji(t)); if(s!==undefined) return pl.h.indexOf(s); }
          }

          let best=[9,-1,0]; pl.h.forEach((t,i)=>{ pl.ct[t]--; const ns=pl.sh(); const uk=ukeire(pl.ct,ns); if(ns<best[0]||ns===best[0]&&uk>best[1]) best=[ns,uk,i]; pl.ct[t]++; }); return best[2]; }

        function callWindow(tile,from){ const left=(from+1)%4; if(!P[left].riichi && chi(left,tile,from)) return true; for(const off of[1,2,3]){ const pid=(from+off)%4; if(!P[pid].riichi && pon(pid,tile,from,off)) return true; } return false; }
        function chi(pid,tile){ const pl=P[pid]; if(tile>=27||pl.win) return false; const prev=pl.sh(); const b=tile%9,s=Math.floor(tile/9), seq=[[b-2,b-1],[b-1,b+1],[b+1,b+2]]; for(const [aB,cB] of seq){ if(aB<0||cB>8) continue; const a=s*9+aB,c=s*9+cB; if(!pl.ct[a]||!pl.ct[c]) continue; pl.ct[a]--; pl.ct[c]--; pl.ct[tile]++; const ns=pl.sh(); pl.ct[a]++; pl.ct[c]++; pl.ct[tile]--; if(ns>=prev) continue; pl.rm(a); pl.rm(c); pl.add(tile); pl.melds.push({tiles:[a,tile,c].sort((x,y)=>x-y),rot:0}); log(`  ‚Üí P${pid} CHII ${span(tile)}\n`); afterCall(pl); return true; } return false; }
        function pon(pid,tile,from,off){ const pl=P[pid]; if(pl.win||pl.ct[tile]<2) return false; const prev=pl.sh(); pl.ct[tile]-=2; pl.ct[tile]++; const ns=pl.sh(); pl.ct[tile]+=2; pl.ct[tile]--; if(ns>=prev) return false; pl.rm(tile); pl.rm(tile); pl.add(tile); const rot=off===1?2:off===2?1:0; pl.melds.push({tiles:[tile,tile,tile],rot}); log(`  ‚Üí P${pid} PON ${span(tile)}\n`); afterCall(pl); return true; }
        function afterCall(pl){ const idx=chooseDiscard(pl); const d=pl.h[idx]; pl.rm(d); pl.disc.push(d); if(pl.riichi) safeTiles.add(d); log(`P${pl.id} descarta ${span(d)} ap√≥s chamada\n`); ronCheck(d,pl.id); cur=pl.id; render(); }

        function ronCheck(tile,from){ for(const p of P){ if(p.id===from||p.win) continue; p.ct[tile]++; if(p.sh()<0){ p.h.push(tile); win(p,"RON",tile,from); return true;} p.ct[tile]--; } return false; }
        function win(pl,how,tile,from){ pl.win=true; render(); log(`\n*** P${pl.id} vence por ${how} em ${span(tile)}${from!==undefined?` (por P${from})`:""} ***\n`); log(`M√£o: ${P[pl.id].h.map(t=>U[t]).join(" ")}\n`); finish(); }

        function draw(){ const t=wall[pos++]; wc[t]--; return t; }
        function log(msg){ logEl.textContent+=msg; logEl.scrollTop=logEl.scrollHeight; }
        function render(){ table.innerHTML=P.map(p=>{ const melds=p.melds.map(m=>`<div class="meld row">${m.tiles.map((t,i)=>span(t,{rot:i===m.rot})).join("")}</div>`).join(""); return `<div class="player${p.win?" winner":""}"><strong>P${p.id}</strong> <small>(sh: ${p.sh()})</small><span class="role ${p.defensive?"def":"off"}">${p.role()}</span>${p.riichi?'<span class="riichi-tag">Riichi!</span>':""}<div class="row hand">${p.h.map(t=>span(t)).join("")}${melds}</div><div class="row discards">${p.disc.map(t=>span(t,{sm:true})).join("")}</div></div>`; }).join(""); }
        function enableButtons(){ next.disabled=false; resetBtn.disabled=false; autoBtn.disabled=false; }
        function finish(){ next.disabled=true; autoBtn.disabled=true; clearInterval(autoTimer); autoTimer=null; autoBtn.textContent="Autoplay ‚ñ∂"; }

        const next=document.getElementById("next"),autoBtn=document.getElementById("auto"),resetBtn=document.getElementById("reset"),table=document.getElementById("table"),logEl=document.getElementById("log");
        next.onclick=step; resetBtn.onclick=initGame; autoBtn.onclick=()=>{ if(autoTimer){ clearInterval(autoTimer); autoTimer=null; autoBtn.textContent="Autoplay ‚ñ∂"; } else { autoBtn.textContent="Autoplay ‚è∏"; autoTimer=setInterval(()=>{ if(!next.disabled) step(); else { clearInterval(autoTimer); autoTimer=null; autoBtn.textContent="Autoplay ‚ñ∂";} },600); } };

        function chooseGenbutsu(pl,sh0){ const g=pl.h.find(t=>safeTiles.has(t)); if(g===undefined) return null; if(pl.defensive) return pl.h.indexOf(g); pl.ct[g]--; const ns=pl.sh(); pl.ct[g]++; return ns<=sh0?pl.h.indexOf(g):null; }
        function chooseDiscard(pl){ if(pl.riichi) return pl.h.indexOf(pl.lastDrawTile); const sh0=pl.sh(); if(riichiActive){ const idxG=chooseGenbutsu(pl,sh0); if(idxG!==null) return idxG; if(pl.defensive){ const s=pl.h.find(t=>isSuji(t)); if(s!==undefined) return pl.h.indexOf(s); } }
          let best=[9,-1,0]; pl.h.forEach((t,i)=>{ pl.ct[t]--; const ns=pl.sh(); const uk=ukeire(pl.ct,ns); if(ns<best[0]||ns===best[0]&&uk>best[1]) best=[ns,uk,i]; pl.ct[t]++; }); return best[2]; }

        initGame();
    </script>
</body>

</html>